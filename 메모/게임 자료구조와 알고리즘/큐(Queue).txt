*선입선출(FIFO - First In,First Out)->먼저 들어오면 먼저 나감

*한쪽 끝(rear)에서는 삽입 연산만 이루어지며 다른 한쪽 끝(front)에서는 삭제 연산만 이루어지는 '유한'순서 리스트이다

*1차원 배열을 이용한 순차표현

*인덱스(주소)를 값으로 가지는 front, rear라는 두개의 변수와 큐의 사이즈를 나타내는 n이라는 변수를 사용

*rear에서 삽입 되므루 rear가 점차 증가하여 rean=n-1인 경우 큐는 full인 상태

용어
1. peek : front에 위치한 데이터를 읽음, 다음 서비스를 받을 손님이 누구인지 확인
2. front : 큐의 맨 앞의 위치,다음 서비스를 받을 손님의 번호
3. rear : 큐의 맨 뒤의 위치, 마지막에 온 손님의 번호
4. enqueue : 큐 맨뒤에 어떠한 요소를 추가
5. dequeue : 큐 맨 앞쪽의 요소를 삭제


단점

*큐에 삽입이 되며 점차 rear가 증가하게 되면 결국 가득차게 된다 하지만 이떼 큐에 원소가 꽉 차있지 않을 수 있다. front에서 삭제가 일어났다면 그만큼 공간이 비었기 때문이다. 따라서 가득차게 되었을때 첫번째 원소의 위치를 큐의 [0]번 주소로 이동한뒤 이것을 기준으로 rear의 위치도 다시 정해주어야 한다

*위의 문제로 순차 표현 큐는 많은 비용(큐 원소 이동에 따른 지연시간)을 발생하게 됨



원형 큐

*큐의 순차표현시 원형큐를 이용하면 원소의 이동없이 사용할 수 있다



원형 큐 예시)
#include<stdio.h>
#include<iostream>

typedef struct _node {
	int data;
}Node;

typedef struct _CircularQueue {
	Node* node;

	int front;
	int rear;
	int capacity;
}CircularQueue;

void CreateQueue(CircularQueue **queue, int capacity) {
	(*queue) = (CircularQueue*)malloc(sizeof(CircularQueue));
	(*queue)->node = (Node*)malloc(sizeof(Node)*capacity+1);
	(*queue)->front = 0;
	(*queue)->rear = 0;
	(*queue)->capacity = capacity;
}

void Enqueue(CircularQueue* queue, int data) 
{
	int Position = 0;
	Position = queue->rear;
	queue->rear = (queue->rear + 1) % (queue->capacity + 1);
	queue->node[Position].data = data;
}

int Dequeue(CircularQueue* queue) 
{
	int Position = queue->front;
	queue->front = (queue->front + 1) % (queue->capacity + 1);
	return queue->node[Position].data;
}

int IsEmpty(CircularQueue* queue)
{
	return (queue->front == queue->rear);
}

int IsFULL(CircularQueue* queue)
{
	if (queue->front < queue->rear)
		return (queue->rear - queue->front) == queue->capacity;
	else
		return (queue->rear + 1) == queue->front;
}

int main()
{
	CircularQueue *queue;
	int max = 0;
	int data;

	printf("용량 입력 : ");
	scanf("%d", &max);

	CreateQueue(&queue,max);
	for (int i = 0; i < max;i++) {
		printf("%d회 데이터 입력 : ",i+1);
		scanf("%d", &data);

		Enqueue(queue, data);
	}

	for (int i = 0; i < max; i++) {
		printf("%d회 데이터 출력 : %d\n", i + 1, Dequeue(queue));
	}

	

	return 0;
}