1. 배열이랑 비슷함

2. 템플릿 기반이므로 임의타입을 요소로 가질수 있으며, 요소 개수에 따라 동적으로 메모리를 관리
-> 사용자가 원하는 타입으로 사용가능 ex) int, float,char
-> 추가 하거나 제거 할 때마다 자동적으로 크기가 조절됨

3. 구조가 단순하고 사용방법이 쉬우며 속도도 빠른편 -> 실용적이라 활용빈도 Up

4. 동일 타입의 자료 집합이며 각 요소는 연속된 위치에 배치된다

5. 연속된 위치에 배치되므로 임의 위치를 빠른 속도로 엑세스 할 수 있다

6. 최상위 레벨의 임의 접근 반복자를 제공하므로 STL의 거의 모든 알고리즘 사용가능

7. 삽입, 삭제 속도가 느리다. 중간 삽입, 삭제는 더 느리다
-> 중간 삽입이 없는 배열을 사용할때 효율 굿

8. at과 i[n]의 차이점은 i[n]은 오류발생이 없고 at은 예외처리로 오류가 난다-> try catch문 사용가능

9. push로 계속 추가 되면 2n으로 용적이 추가됨 -> 계속 요소가 추가되면 부하가 늘어남 -> reserve 로 미리 용적을 할당하고 사용하면 부하가 덜 함

10. 큰용적을 작은용적으로 resize 하면 뒤쪽 요소를 버려버림

11. vector가 선언되고 초기화 및 값이 들어가지 않으면 쓰레기값이 아닌 기본size는 0으로 들어감

12. 이중for문은 리스크가 크기때문에 지양

13. C,C++사용시 동적할당 메모리도 중요하지만 복잡도랑 연관관계 없음-> 복잡도 우선순위up

14. []는 오류 발생시 알려주지 않지만 at 은 예외처리 발생시킴 오류 줄임->at이 안정적

15. capacity가 늘어날때 두배씩 늘어남

16.reserve로 할당해놓고 쓰는게 좋다 양이 많을시

17.out_of_range는 타입명

18.벡터랑 덱만 증감연산자로 조정가능

vector와 배열

배열의 크기는 고정이지만 vector는 요소 개수에 따라 동적으로 늘어난다

배열과 vector 모두 사용방법이 쉽다

배열과 vector 모두 데이터를 연속된 위치에 순차적으로 저장한다

연속된 위치에 순차적으로 저장하므로 랜덤 엑세스가 가능하다

속도는 보통 배열이 vector보다 빠르다


vector를 사용해야 하는경우

저장할 데이터의 개수가 가변적일때

중간에 데이터 삽입, 삭제가 적거나 없을때

저장된 요소를 자주 검색하지 않을때

랜덤 엑세스를 자주 할때

벡터 기본 함수

반복자
begin() : begining iterator(반복자)를 반환
end() : end iteratior를 반환

추가 및 삭제
push_back(변수) : 제일 뒤에 원소 추가
pop_back() : 제일 뒤에 있는 원소 하나 삭제

조회
[i] : i번째 원소를 반환
at(i) :	     "    
front() : 첫번째 원소를 반환
back() : 마지막 원소를 반환

기타
empty() : 벡터가 비어있으면 true 아니면 false를 반환
size() : 벡터 원소들의 수를 반환

사용법

vector<자료형>변수;  //선언
ex)vector<int>damage;

변수.push_back(추가할값);
ex)damage.push_back(500);
    damage.push_back(159);

damage[0] 은 500
damage[1] 은 159




vector<int>::reverse_iterator riter(v.rbegin());   == 	vector<int>::reverse_iterator riter=v.begin();
이렇게도 사용할수있다