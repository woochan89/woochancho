1. 배열이랑 비슷함

2. 템플릿 기반이므로 임의타입을 요소로 가질수 있으며, 요소 개수에 따라 동적으로 메모리를 관리
-> 사용자가 원하는 타입으로 사용가능 ex) int, float,char
-> 추가 하거나 제거 할 때마다 자동적으로 크기가 조절됨
3. 구조가 단순하고 사용방법이 쉬우며 속도도 빠른편 -> 실용적이라 활용빈도 Up

4. 동일 타입의 자료 집합이며 각 요소는 연속된 위치에 배치된다

5. 연속된 위치에 배치되므로 임의 위치를 빠른 속도로 엑세스 할 수 있다

6. 최상위 레벨의 임의 접근 반복자를 제공하므로 STL의 거의 모든 알고리즘 사용가능

7. 삽입, 삭제 속도가 느리다. 중간 삽입, 삭제는 더 느리다
-> 중간 삽입이 없는 배열을 사용할때 효율 굿

vector와 배열

배열의 크기는 고정이지만 vector는 요소 개수에 따라 동적으로 늘어난다

배열과 vector 모두 사용방법이 쉽다

배열과 vector 모두 데이터를 연속된 위치에 순차적으로 저장한다

연속된 위치에 순차적으로 저장하므로 랜덤 엑세스가 가능하다

속도는 보통 배열이 vector보다 빠르다


vector를 사용해야 하는경우

저장할 데이터의 개수가 가변적일때

중간에 데이터 삽입, 삭제가 적거나 없을때

저장된 요소를 자주 검색하지 않을때

랜덤 엑세스를 자주 할때

벡터 기본 함수

반복자
begin() : begining iterator(반복자)를 반환
end() : end iteratior를 반환

추가 및 삭제
push_back(변수) : 제일 뒤에 원소 추가
pop_back() : 제일 뒤에 있는 원소 하나 삭제

조회
[i] : i번째 원소를 반환
at(i) :	     "    
front() : 첫번째 원소를 반환
back() : 마지막 원소를 반환

기타
empty() : 벡터가 비어있으면 true 아니면 false를 반환
suze() : 벡터 원소들의 수를 반환

사용법

vector<자료형>변수;  //선언
ex)vector<int>damage;

변수.push_back(추가할값);
ex)damage.push_back(500);
    damage.push_back(159);

damage[0] 은 500
damage[1] 은 159

