const(상수화)

특징

1. 수정을 금지하기 위해 붙이는 키워드-> 변수를 상수화 하는 기능
->변수는 일정범위내에서 다양한 값으로 변화가 가능, 상수는 항상 같은 값을 가지는 것
2. 이미 정해진 상수 외에 우리가 새롭게 상수를 만들어주는 작업
3. 일반적으로 자료형의 앞이나 뒤에 붙지만 주로 앞에 붙임-> 어느쪽이든 같은 기능
4. 자료형에 const를 붙이는 경우 클래스의 멤버변수가 아니라면 초기화 해줘야함 -> 초기화 안하면 영영 못씀
5. 포인터 변수의 경우는 const가 앞에 붙느냐, 뒤에 붙느냐에 따라 의미가 다름
-> 앞에 붙는 경우 포인터 변수 안에 있는 내용물의 수정을 금지하고(주소값 변경O, 값 변경 X)
-> 뒤에 붙는 경우 포인터 변수의 값을 수정하는 것을 금지함(주소값 변경X, 값 변경 O)
6. 앞뒤로 const 붙혀서도 사용가능 한대 이땐 값과 주소값 둘다 변경 불가능




구조체 const 주의점

1. 구조체의 멤버변수로서 const가 붙는 경우 구조체 변수를 생성할때 초기화 해야함

typedef struct _a {
	const int b;
	struct _a() :b(5) {}
}A;

이런식으로 생성자를 사용해서 내부에서 초기화가능


클래스 const

클래스의 멤버 함수 뒤에 const를 붙혀 함수 내부에서 멤버변수의 값을 변경시키지 못하게 할수있다

ex)
class A{
public:
    int a;
    int getA(int i) const
    {
        a=5;  //에러
        int b;
        b=8;
        i=7;
        return a;
    }
};



아래 메인문에서 구조체 a는 콘스트로 선언되어 있는데 getA() 함수는 멤버변수를 바꾸지 않는다는 보장이 없기 때문에 오류가 나므로 getA2()const 처럼 사용해야 오류가 나지 않는다

ex)
class A{
    const int a;
    int b;
public:
    A():a(2){b=5;}
    A(int i):a(2){}
    int getA(){ return a; }
    int getA2()const{ return a; }
};
void main()
{
    const A a(3);
    printf("%d\n", a.getA());  //에러
    printf("%d\n", a.getA2());
}