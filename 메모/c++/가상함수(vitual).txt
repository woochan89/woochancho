특징

1.기본 클래스(상속되지 않은 클래스)내에서 선언되어 파생 클래스에 의해 재정의 되는 맴버함수

2. 포인터 또는 기본 클래스에 대한 참조를 사용하여 파생 클래스의 객체를 참조하면 해당 객체에 대해 가상함수를 호출하고 파생클래스의 함수를 실행할 수 있습니다

3. 주로 실행시간(Runtime)에 함수의 다형성(Polymorphism)을 구현하는데 사용됨

4. 가상함수는 기본 클래스내에 virtual키워드로 함수를 선언합니다.

5. 오버라이딩이 가능해진다(상속관계에서 오버라이딩을 하기 위해선 가상함수여야 한다)

6. 순수 가상함수 : 부모의 가상함수에서 =0; 을 붙히면 구현 하지 않고 오로지 자식에서만 사용하겠다는 뜻-> 자식 클래스에서 재정의 해주지 않는다면 오류 발생함

7. 추상 클래스 : 순수 가상함수가 포함되면 추상클래스로 지정되고, 추상클래스가 되면 객체를 생성할수 없음-> 이 클래스로 부터 다른 자식 클래스를 파생 시켜서 모든 순수 멤버 가상함수를 오버라이드 한 뒤, 해당 자식 클래스 부터 인스턴스를 다시 생성할수 있음

8. C++컴파일러가 실제로 가리키는 객체의 자료형을 기준으로 하는게 아닌, 포인터 변수의 자료형을 기준으로 판단한다 
ex)
int main()
{
Parent P, *pP;
Child C;
pP=&P;
pP->func();
pP=&C;
pP->func();
return 0;
}-> 에서 pP에 담긴 실체는 Child 인스턴스 지만 포인터 변수 *pP의 자료형이 Parent이므로 pP의 함수를 호출함

9. 부모 자식 상속 관계에서 생성자는 관계 없지만 소멸자 사용시 부모의 소멸자만 호출하고 자식의 소멸자는 호출하지 않는데 부모의 소멸자 앞에 virtual을 붙힘으로써 자식의 소멸자 까지 호출가능-> 재정의 가능성이 조금이라도 있으면 virtual 붙히는게 오류발생 줄임

10. 오버라이딩은 자식 클래스에서 부모 클래스의 함수를 재정의 하는 행위이고, 가상함수는 오버라이딩 하기위해 함수 앞에 virtual을 붙히는 행위

규칙

1. 클래스의 public 섹션에 선언

2. 가상 함수는 static일수 없으며 다른 클래스의 friend 함수가 될 수도 없다

3. 가상 함수는 실행시간 다형성을 얻기위해 기본 클래스의 포인터 또는 참조(상속?)를 통해 접근해야 한다

4. 가상 함수의 프로토타입(반환형과 매개변수)은 기본 클래스와 파생 클래스에서 동일합니다

5. 클래스는 가상 소멸자를 가질 수 있지만 가상 생성자를 가질수 없다




가상함수는 포인터처럼 해당 함수가 실행될때 다른 영향을 받아 그 값이 결정된다

주의할것은 부모가 상속받은 자식을 선언하는 방식
ex)부모 = &자식; 

간단히 말해서 virtual함수를 사용하면 상속받은 자식의 함수를 실행함

virtual함수를 사용하더라도 상속받은 자식 함수에서 부모함수와 매개변수가 같지않다면 부모함수가 실행됨(오류가 뜨진 않음)

https://yeolco.tistory.com/125 참조